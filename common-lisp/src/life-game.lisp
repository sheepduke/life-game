(in-package :life-game)

(defun make-empty-board (size)
  "Return an empty board of given SIZE."
  (declare (type fixnum size))
  (the (simple-array boolean 2)
       (make-array (list size size)
                   :element-type 'boolean
                   :initial-element nil
                   :adjustable nil)))

(defun make-board (size seed-count)
  "Return a BOARD object of given SIZE."
  (let* ((board (make-empty-board size))
         (range (* size size))
         (state (make-random-state t)))
    (iterate (while (> seed-count 0))
             (let* ((position (random range state))
                    (row (floor (/ position size)))
                    (col (rem position size)))
               (unless (aref board row col)
                 (setf (aref board row col) t)
                 (decf seed-count))))
    board))

(declaim (inline board-size))
(defun board-size (board)
  (declare (type (simple-array boolean 2) board))
  (array-dimension board 0))

(defun print-board (board &optional (stream t))
  "Method for printing board"
  (iter (for row from 0 below (board-size board))
    (iter (for col from 0 below (board-size board))
      (format stream "~A " (if (aref board row col) #\# #\-)))
  ;; (iter (for row in-vector board)
  ;;       (iter (for cell in-vector row)
  ;;         )
    (format stream "~&")))

(declaim (inline cell-alive-p))
(defun cell-alive-p (board row col)
  (declare (type fixnum row col)
           (type (simple-array boolean 2) board))
  (let ((neighbour-count (neighbour-count board row col)))
    (or (= neighbour-count 3)
        (and (= neighbour-count 2)
             (aref board row col)))))

(declaim (inline neighbour-count))
(defun neighbour-count (board row col)
  "Return T if given cell shall remain alive or reborn."
  (declare (type fixnum row col)
           (type (simple-array boolean 2) board))
  (let* ((size (board-size board))
         (row-start (if (> row 0) (1- row) row))
         (row-end (if (< row (1- size)) (1+ row) row))
         (col-start (if (> col 0) (1- col) col))
         (col-end (if (< col (1- size)) (1+ col) col))
         (count 0))
    (iter (for i from row-start to row-end)
      (iter (for j from col-start to col-end)
        (when (aref board i j)
          (incf count))))
    (when (aref board row col)
      (decf count))
    count))

(defun evolve (board)
  "Evolve to the next turn."
  (declare (optimize (speed 3) (safety 0)))
  (let* ((size (board-size board))
         (new-board (make-empty-board size)))
    (iter (for row from 0 below size)
          (iter (for col from 0 below size)
                (setf (aref new-board row col)
                      (cell-alive-p board row col))))
    new-board))
